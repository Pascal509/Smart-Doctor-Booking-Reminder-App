{"ast":null,"code":"import _objectSpread from\"C:/Users/HP/Smart-Doctor-Booking-Reminder-App/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// Authentication Context for global state management\nimport React,{createContext,useContext,useReducer,useEffect}from'react';import{login as apiLogin,validateToken,logout as apiLogout}from'../api/clients/authApi';import{getToken,getUser,clearAuthData}from'../utils/tokenStorage';// Initial authentication state\nimport{jsx as _jsx}from\"react/jsx-runtime\";const initialAuthState={isAuthenticated:false,user:null,token:null,loading:true,// Start with loading true to check existing session\nerror:null};// Authentication action types\n// Authentication reducer\nconst authReducer=(state,action)=>{switch(action.type){case'LOGIN_START':return _objectSpread(_objectSpread({},state),{},{loading:true,error:null});case'LOGIN_SUCCESS':return _objectSpread(_objectSpread({},state),{},{isAuthenticated:true,user:action.payload.user,token:action.payload.token,loading:false,error:null});case'LOGIN_FAILURE':return _objectSpread(_objectSpread({},state),{},{isAuthenticated:false,user:null,token:null,loading:false,error:action.payload});case'LOGOUT':return _objectSpread(_objectSpread({},state),{},{isAuthenticated:false,user:null,token:null,loading:false,error:null});case'CLEAR_ERROR':return _objectSpread(_objectSpread({},state),{},{error:null});case'SET_LOADING':return _objectSpread(_objectSpread({},state),{},{loading:action.payload});case'RESTORE_SESSION':return _objectSpread(_objectSpread({},state),{},{isAuthenticated:true,user:action.payload.user,token:action.payload.token,loading:false,error:null});default:return state;}};// Create the context\nconst AuthContext=/*#__PURE__*/createContext(undefined);// AuthProvider component props\n// AuthProvider component\nexport const AuthProvider=_ref=>{let{children}=_ref;const[authState,dispatch]=useReducer(authReducer,initialAuthState);// Check for existing session on mount\nuseEffect(()=>{const checkExistingSession=async()=>{try{const existingToken=getToken();const existingUser=getUser();if(existingToken&&existingUser){// Validate token with backend\ntry{const validationResult=await validateToken();if(validationResult.valid){// Session is valid, restore it\ndispatch({type:'RESTORE_SESSION',payload:{user:{user_id:validationResult.user_id,username:validationResult.username,role:validationResult.role},token:existingToken}});}else{// Token is invalid, clear storage\nclearAuthData();dispatch({type:'SET_LOADING',payload:false});}}catch(error){// Token validation failed, clear storage\nclearAuthData();dispatch({type:'SET_LOADING',payload:false});}}else{// No existing session\ndispatch({type:'SET_LOADING',payload:false});}}catch(error){console.error('Error checking existing session:',error);dispatch({type:'SET_LOADING',payload:false});}};checkExistingSession();},[]);// Login function\nconst login=async credentials=>{dispatch({type:'LOGIN_START'});try{const loginResponse=await apiLogin(credentials);const user={user_id:loginResponse.user_id,username:loginResponse.username,role:loginResponse.role};dispatch({type:'LOGIN_SUCCESS',payload:{user,token:loginResponse.token}});}catch(error){const errorMessage=error.message||'Login failed. Please try again.';dispatch({type:'LOGIN_FAILURE',payload:errorMessage});throw error;// Re-throw so components can handle it\n}};// Logout function\nconst logout=async()=>{try{// Call backend logout (optional, for token blacklisting)\nawait apiLogout();}catch(error){console.warn('Backend logout failed:',error);}finally{// Always clear local data\nclearAuthData();dispatch({type:'LOGOUT'});}};// Clear error function\nconst clearError=()=>{dispatch({type:'CLEAR_ERROR'});};// Context value\nconst contextValue={authState,login,logout,clearError};return/*#__PURE__*/_jsx(AuthContext.Provider,{value:contextValue,children:children});};// Custom hook to use the auth context\nexport const useAuth=()=>{const context=useContext(AuthContext);if(context===undefined){throw new Error('useAuth must be used within an AuthProvider');}return context;};// Export the context for advanced use cases\nexport{AuthContext};","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","login","apiLogin","validateToken","logout","apiLogout","getToken","getUser","clearAuthData","jsx","_jsx","initialAuthState","isAuthenticated","user","token","loading","error","authReducer","state","action","type","_objectSpread","payload","AuthContext","undefined","AuthProvider","_ref","children","authState","dispatch","checkExistingSession","existingToken","existingUser","validationResult","valid","user_id","username","role","console","credentials","loginResponse","errorMessage","message","warn","clearError","contextValue","Provider","value","useAuth","context","Error"],"sources":["C:/Users/HP/Smart-Doctor-Booking-Reminder-App/frontend/src/contexts/AuthContext.tsx"],"sourcesContent":["// Authentication Context for global state management\n\nimport React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';\nimport { AuthState, AuthContextType, LoginData, AuthUser } from '../api/types/auth';\nimport { login as apiLogin, validateToken, logout as apiLogout } from '../api/clients/authApi';\nimport { getToken, getUser, clearAuthData } from '../utils/tokenStorage';\n\n// Initial authentication state\nconst initialAuthState: AuthState = {\n  isAuthenticated: false,\n  user: null,\n  token: null,\n  loading: true, // Start with loading true to check existing session\n  error: null,\n};\n\n// Authentication action types\ntype AuthAction =\n  | { type: 'LOGIN_START' }\n  | { type: 'LOGIN_SUCCESS'; payload: { user: AuthUser; token: string } }\n  | { type: 'LOGIN_FAILURE'; payload: string }\n  | { type: 'LOGOUT' }\n  | { type: 'CLEAR_ERROR' }\n  | { type: 'SET_LOADING'; payload: boolean }\n  | { type: 'RESTORE_SESSION'; payload: { user: AuthUser; token: string } };\n\n// Authentication reducer\nconst authReducer = (state: AuthState, action: AuthAction): AuthState => {\n  switch (action.type) {\n    case 'LOGIN_START':\n      return {\n        ...state,\n        loading: true,\n        error: null,\n      };\n    \n    case 'LOGIN_SUCCESS':\n      return {\n        ...state,\n        isAuthenticated: true,\n        user: action.payload.user,\n        token: action.payload.token,\n        loading: false,\n        error: null,\n      };\n    \n    case 'LOGIN_FAILURE':\n      return {\n        ...state,\n        isAuthenticated: false,\n        user: null,\n        token: null,\n        loading: false,\n        error: action.payload,\n      };\n    \n    case 'LOGOUT':\n      return {\n        ...state,\n        isAuthenticated: false,\n        user: null,\n        token: null,\n        loading: false,\n        error: null,\n      };\n    \n    case 'CLEAR_ERROR':\n      return {\n        ...state,\n        error: null,\n      };\n    \n    case 'SET_LOADING':\n      return {\n        ...state,\n        loading: action.payload,\n      };\n    \n    case 'RESTORE_SESSION':\n      return {\n        ...state,\n        isAuthenticated: true,\n        user: action.payload.user,\n        token: action.payload.token,\n        loading: false,\n        error: null,\n      };\n    \n    default:\n      return state;\n  }\n};\n\n// Create the context\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// AuthProvider component props\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\n// AuthProvider component\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [authState, dispatch] = useReducer(authReducer, initialAuthState);\n\n  // Check for existing session on mount\n  useEffect(() => {\n    const checkExistingSession = async () => {\n      try {\n        const existingToken = getToken();\n        const existingUser = getUser();\n\n        if (existingToken && existingUser) {\n          // Validate token with backend\n          try {\n            const validationResult = await validateToken();\n            \n            if (validationResult.valid) {\n              // Session is valid, restore it\n              dispatch({\n                type: 'RESTORE_SESSION',\n                payload: {\n                  user: {\n                    user_id: validationResult.user_id,\n                    username: validationResult.username,\n                    role: validationResult.role,\n                  },\n                  token: existingToken,\n                },\n              });\n            } else {\n              // Token is invalid, clear storage\n              clearAuthData();\n              dispatch({ type: 'SET_LOADING', payload: false });\n            }\n          } catch (error) {\n            // Token validation failed, clear storage\n            clearAuthData();\n            dispatch({ type: 'SET_LOADING', payload: false });\n          }\n        } else {\n          // No existing session\n          dispatch({ type: 'SET_LOADING', payload: false });\n        }\n      } catch (error) {\n        console.error('Error checking existing session:', error);\n        dispatch({ type: 'SET_LOADING', payload: false });\n      }\n    };\n\n    checkExistingSession();\n  }, []);\n\n  // Login function\n  const login = async (credentials: LoginData): Promise<void> => {\n    dispatch({ type: 'LOGIN_START' });\n\n    try {\n      const loginResponse = await apiLogin(credentials);\n      \n      const user: AuthUser = {\n        user_id: loginResponse.user_id,\n        username: loginResponse.username,\n        role: loginResponse.role,\n      };\n\n      dispatch({\n        type: 'LOGIN_SUCCESS',\n        payload: {\n          user,\n          token: loginResponse.token,\n        },\n      });\n    } catch (error: any) {\n      const errorMessage = error.message || 'Login failed. Please try again.';\n      dispatch({\n        type: 'LOGIN_FAILURE',\n        payload: errorMessage,\n      });\n      throw error; // Re-throw so components can handle it\n    }\n  };\n\n  // Logout function\n  const logout = async (): Promise<void> => {\n    try {\n      // Call backend logout (optional, for token blacklisting)\n      await apiLogout();\n    } catch (error) {\n      console.warn('Backend logout failed:', error);\n    } finally {\n      // Always clear local data\n      clearAuthData();\n      dispatch({ type: 'LOGOUT' });\n    }\n  };\n\n  // Clear error function\n  const clearError = (): void => {\n    dispatch({ type: 'CLEAR_ERROR' });\n  };\n\n  // Context value\n  const contextValue: AuthContextType = {\n    authState,\n    login,\n    logout,\n    clearError,\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// Custom hook to use the auth context\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  \n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  \n  return context;\n};\n\n// Export the context for advanced use cases\nexport { AuthContext };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}