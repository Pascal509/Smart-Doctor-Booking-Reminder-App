{"ast":null,"code":"import apiClient from '../utils/apiClient';\n\n/**\n * Books a new appointment with the specified doctor\n * \n * @param data - Booking data containing doctor_id, patient_id, appointment_time, and optional notes\n * @returns Promise<BookingResponse> - Booking confirmation with appointment details\n * @throws Error - When the API request fails or returns an error\n * \n * OpenAPI Specification:\n * POST /api/v1/appointments/book\n * \n * Request Body:\n * {\n *   \"doctor_id\": number,\n *   \"patient_id\": number,\n *   \"appointment_time\": string (ISO 8601 format),\n *   \"notes\": string (optional)\n * }\n * \n * Success Response (201):\n * {\n *   \"appointment_id\": number,\n *   \"doctor_id\": number,\n *   \"patient_id\": number,\n *   \"appointment_time\": string,\n *   \"status\": string,\n *   \"notes\": string,\n *   \"created_at\": string,\n *   \"message\": string\n * }\n * \n * Error Responses:\n * 400 - Bad Request (invalid data)\n * 401 - Unauthorized (authentication required)\n * 403 - Forbidden (insufficient permissions)\n * 404 - Not Found (doctor not found)\n * 409 - Conflict (time slot not available)\n * 422 - Unprocessable Entity (validation errors)\n */\nexport const bookAppointment = async data => {\n  try {\n    // Validate required fields\n    if (!data.doctor_id || !data.patient_id || !data.appointment_time) {\n      throw new Error('Doctor ID, Patient ID, and appointment time are required');\n    }\n\n    // Validate appointment time format (basic ISO 8601 check)\n    const appointmentDate = new Date(data.appointment_time);\n    if (isNaN(appointmentDate.getTime())) {\n      throw new Error('Invalid appointment time format. Please use ISO 8601 format.');\n    }\n\n    // Check if appointment time is in the future\n    if (appointmentDate <= new Date()) {\n      throw new Error('Appointment time must be in the future.');\n    }\n    const response = await apiClient.post('/appointments/book', {\n      doctor_id: data.doctor_id,\n      patient_id: data.patient_id,\n      appointment_time: data.appointment_time,\n      notes: data.notes || ''\n    });\n    return response;\n  } catch (error) {\n    var _error$response3;\n    // Handle specific error cases\n    if (error.status === 401) {\n      throw new Error('Authentication failed - please log in again');\n    }\n    if (error.status === 403) {\n      throw new Error('You do not have permission to book appointments');\n    }\n    if (error.status === 404) {\n      throw new Error('Doctor not found or not available');\n    }\n    if (error.status === 409) {\n      throw new Error('The selected time slot is no longer available. Please choose a different time.');\n    }\n    if (error.status === 422) {\n      var _error$response;\n      const validationMessage = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.message) || 'Invalid appointment data provided';\n      throw new Error(validationMessage);\n    }\n    if (error.status === 400) {\n      var _error$response2;\n      const badRequestMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.message) || 'Invalid request data';\n      throw new Error(badRequestMessage);\n    }\n\n    // Generic error handling\n    const message = ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.message) || error.message || 'Failed to book appointment';\n    throw new Error(message);\n  }\n};\n\n/**\n * Gets available time slots for a specific doctor on a given date\n * \n * @param doctorId - The ID of the doctor\n * @param date - The date to check availability (YYYY-MM-DD format)\n * @returns Promise<string[]> - Array of available time slots in ISO 8601 format\n * @throws Error - When the API request fails or returns an error\n */\nexport const getAvailableSlots = async (doctorId, date) => {\n  try {\n    if (!doctorId || !date) {\n      throw new Error('Doctor ID and date are required');\n    }\n    const response = await apiClient.get(`/appointments/availability?doctor_id=${doctorId}&date=${date}`);\n    return response;\n  } catch (error) {\n    var _error$response4;\n    if (error.status === 401) {\n      throw new Error('Authentication failed - please log in again');\n    }\n    if (error.status === 404) {\n      throw new Error('Doctor not found or no availability information');\n    }\n    const message = ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.message) || error.message || 'Failed to fetch available time slots';\n    throw new Error(message);\n  }\n};\n\n/**\n * Cancels an existing appointment\n * \n * @param id - The ID of the appointment to cancel\n * @param reason - Optional reason for cancellation\n * @returns Promise<void> - Resolves when cancellation is successful\n * @throws Error - When the API request fails or returns an error\n * \n * OpenAPI Specification:\n * DELETE /api/v1/appointments/:id/cancel\n * \n * Request Body:\n * {\n *   \"reason\": string (optional)\n * }\n * \n * Success Response (200):\n * {\n *   \"success\": true,\n *   \"message\": string\n * }\n * \n * Error Responses:\n * 400 - Bad Request (invalid appointment ID)\n * 401 - Unauthorized (authentication required)\n * 403 - Forbidden (insufficient permissions)\n * 404 - Not Found (appointment not found)\n * 409 - Conflict (appointment cannot be cancelled)\n */\nexport const cancelAppointment = async (id, reason) => {\n  try {\n    // Validate required fields\n    if (!id || id <= 0) {\n      throw new Error('Valid appointment ID is required');\n    }\n    await apiClient.delete(`/appointments/${id}/cancel`, {\n      data: {\n        reason: reason || 'Cancelled by patient'\n      }\n    });\n  } catch (error) {\n    var _error$response6;\n    // Handle specific error cases\n    if (error.status === 401) {\n      throw new Error('Authentication failed - please log in again');\n    }\n    if (error.status === 403) {\n      throw new Error('You do not have permission to cancel this appointment');\n    }\n    if (error.status === 404) {\n      throw new Error('Appointment not found or has already been cancelled');\n    }\n    if (error.status === 409) {\n      throw new Error('This appointment cannot be cancelled at this time');\n    }\n    if (error.status === 400) {\n      var _error$response5;\n      const badRequestMessage = ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.message) || 'Invalid appointment ID or request data';\n      throw new Error(badRequestMessage);\n    }\n\n    // Generic error handling\n    const message = ((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.message) || error.message || 'Failed to cancel appointment';\n    throw new Error(message);\n  }\n};","map":{"version":3,"names":["apiClient","bookAppointment","data","doctor_id","patient_id","appointment_time","Error","appointmentDate","Date","isNaN","getTime","response","post","notes","error","_error$response3","status","_error$response","validationMessage","message","_error$response2","badRequestMessage","getAvailableSlots","doctorId","date","get","_error$response4","cancelAppointment","id","reason","delete","_error$response6","_error$response5"],"sources":["C:/Users/HP/Smart-Doctor-Booking-Reminder-App/frontend/src/services/appointmentApi.ts"],"sourcesContent":["import { BookingData, BookingResponse } from '../types/api';\nimport apiClient from '../utils/apiClient';\n\n/**\n * Books a new appointment with the specified doctor\n * \n * @param data - Booking data containing doctor_id, patient_id, appointment_time, and optional notes\n * @returns Promise<BookingResponse> - Booking confirmation with appointment details\n * @throws Error - When the API request fails or returns an error\n * \n * OpenAPI Specification:\n * POST /api/v1/appointments/book\n * \n * Request Body:\n * {\n *   \"doctor_id\": number,\n *   \"patient_id\": number,\n *   \"appointment_time\": string (ISO 8601 format),\n *   \"notes\": string (optional)\n * }\n * \n * Success Response (201):\n * {\n *   \"appointment_id\": number,\n *   \"doctor_id\": number,\n *   \"patient_id\": number,\n *   \"appointment_time\": string,\n *   \"status\": string,\n *   \"notes\": string,\n *   \"created_at\": string,\n *   \"message\": string\n * }\n * \n * Error Responses:\n * 400 - Bad Request (invalid data)\n * 401 - Unauthorized (authentication required)\n * 403 - Forbidden (insufficient permissions)\n * 404 - Not Found (doctor not found)\n * 409 - Conflict (time slot not available)\n * 422 - Unprocessable Entity (validation errors)\n */\nexport const bookAppointment = async (data: BookingData): Promise<BookingResponse> => {\n  try {\n    // Validate required fields\n    if (!data.doctor_id || !data.patient_id || !data.appointment_time) {\n      throw new Error('Doctor ID, Patient ID, and appointment time are required');\n    }\n\n    // Validate appointment time format (basic ISO 8601 check)\n    const appointmentDate = new Date(data.appointment_time);\n    if (isNaN(appointmentDate.getTime())) {\n      throw new Error('Invalid appointment time format. Please use ISO 8601 format.');\n    }\n\n    // Check if appointment time is in the future\n    if (appointmentDate <= new Date()) {\n      throw new Error('Appointment time must be in the future.');\n    }\n\n    const response = await apiClient.post<BookingResponse>(\n      '/appointments/book',\n      {\n        doctor_id: data.doctor_id,\n        patient_id: data.patient_id,\n        appointment_time: data.appointment_time,\n        notes: data.notes || ''\n      }\n    );\n\n    return response;\n  } catch (error: any) {\n    // Handle specific error cases\n    if (error.status === 401) {\n      throw new Error('Authentication failed - please log in again');\n    }\n    \n    if (error.status === 403) {\n      throw new Error('You do not have permission to book appointments');\n    }\n    \n    if (error.status === 404) {\n      throw new Error('Doctor not found or not available');\n    }\n    \n    if (error.status === 409) {\n      throw new Error('The selected time slot is no longer available. Please choose a different time.');\n    }\n    \n    if (error.status === 422) {\n      const validationMessage = error.response?.message || 'Invalid appointment data provided';\n      throw new Error(validationMessage);\n    }\n    \n    if (error.status === 400) {\n      const badRequestMessage = error.response?.message || 'Invalid request data';\n      throw new Error(badRequestMessage);\n    }\n    \n    // Generic error handling\n    const message = error.response?.message || error.message || 'Failed to book appointment';\n    throw new Error(message);\n  }\n};\n\n/**\n * Gets available time slots for a specific doctor on a given date\n * \n * @param doctorId - The ID of the doctor\n * @param date - The date to check availability (YYYY-MM-DD format)\n * @returns Promise<string[]> - Array of available time slots in ISO 8601 format\n * @throws Error - When the API request fails or returns an error\n */\nexport const getAvailableSlots = async (doctorId: number, date: string): Promise<string[]> => {\n  try {\n    if (!doctorId || !date) {\n      throw new Error('Doctor ID and date are required');\n    }\n\n    const response = await apiClient.get<string[]>(\n      `/appointments/availability?doctor_id=${doctorId}&date=${date}`\n    );\n\n    return response;\n  } catch (error: any) {\n    if (error.status === 401) {\n      throw new Error('Authentication failed - please log in again');\n    }\n    \n    if (error.status === 404) {\n      throw new Error('Doctor not found or no availability information');\n    }\n    \n    const message = error.response?.message || error.message || 'Failed to fetch available time slots';\n    throw new Error(message);\n  }\n};\n\n/**\n * Cancels an existing appointment\n * \n * @param id - The ID of the appointment to cancel\n * @param reason - Optional reason for cancellation\n * @returns Promise<void> - Resolves when cancellation is successful\n * @throws Error - When the API request fails or returns an error\n * \n * OpenAPI Specification:\n * DELETE /api/v1/appointments/:id/cancel\n * \n * Request Body:\n * {\n *   \"reason\": string (optional)\n * }\n * \n * Success Response (200):\n * {\n *   \"success\": true,\n *   \"message\": string\n * }\n * \n * Error Responses:\n * 400 - Bad Request (invalid appointment ID)\n * 401 - Unauthorized (authentication required)\n * 403 - Forbidden (insufficient permissions)\n * 404 - Not Found (appointment not found)\n * 409 - Conflict (appointment cannot be cancelled)\n */\nexport const cancelAppointment = async (id: number, reason?: string): Promise<void> => {\n  try {\n    // Validate required fields\n    if (!id || id <= 0) {\n      throw new Error('Valid appointment ID is required');\n    }\n\n    await apiClient.delete(\n      `/appointments/${id}/cancel`,\n      {\n        data: {\n          reason: reason || 'Cancelled by patient'\n        }\n      }\n    );\n  } catch (error: any) {\n    // Handle specific error cases\n    if (error.status === 401) {\n      throw new Error('Authentication failed - please log in again');\n    }\n    \n    if (error.status === 403) {\n      throw new Error('You do not have permission to cancel this appointment');\n    }\n    \n    if (error.status === 404) {\n      throw new Error('Appointment not found or has already been cancelled');\n    }\n    \n    if (error.status === 409) {\n      throw new Error('This appointment cannot be cancelled at this time');\n    }\n    \n    if (error.status === 400) {\n      const badRequestMessage = error.response?.message || 'Invalid appointment ID or request data';\n      throw new Error(badRequestMessage);\n    }\n    \n    // Generic error handling\n    const message = error.response?.message || error.message || 'Failed to cancel appointment';\n    throw new Error(message);\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}