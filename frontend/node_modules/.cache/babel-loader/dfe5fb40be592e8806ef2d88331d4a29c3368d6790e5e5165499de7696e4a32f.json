{"ast":null,"code":"import { ApiError } from '../types/api';\nimport apiClient from './apiClient';\n\n/**\n * Books a new appointment with the specified doctor\n * \n * @param data - Booking data containing doctor_id, patient_id, appointment_time, and optional notes\n * @returns Promise<BookingResponse> - Booking confirmation with appointment details\n * @throws Error - When the API request fails or returns an error\n * \n * OpenAPI Specification:\n * POST /api/v1/appointments/book\n * \n * Request Body:\n * {\n *   \"doctor_id\": number,\n *   \"patient_id\": number,\n *   \"appointment_time\": string (ISO 8601 format),\n *   \"notes\": string (optional)\n * }\n * \n * Success Response (201):\n * {\n *   \"appointment_id\": number,\n *   \"doctor_id\": number,\n *   \"patient_id\": number,\n *   \"appointment_time\": string,\n *   \"status\": string,\n *   \"notes\": string,\n *   \"created_at\": string,\n *   \"message\": string\n * }\n * \n * Error Responses:\n * 400 - Bad Request (invalid data)\n * 401 - Unauthorized (authentication required)\n * 403 - Forbidden (insufficient permissions)\n * 404 - Not Found (doctor not found)\n * 409 - Conflict (time slot not available)\n * 422 - Unprocessable Entity (validation errors)\n */\nexport const bookAppointment = async data => {\n  try {\n    // Validate required fields\n    if (!data.doctor_id || !data.patient_id || !data.appointment_time) {\n      throw new Error('Doctor ID, Patient ID, and appointment time are required');\n    }\n\n    // Validate appointment time format (basic ISO 8601 check)\n    const appointmentDate = new Date(data.appointment_time);\n    if (isNaN(appointmentDate.getTime())) {\n      throw new Error('Invalid appointment time format. Please use ISO 8601 format.');\n    }\n\n    // Check if appointment time is in the future\n    if (appointmentDate <= new Date()) {\n      throw new Error('Appointment time must be in the future.');\n    }\n    const response = await apiClient.post('/appointments/book', {\n      doctor_id: data.doctor_id,\n      patient_id: data.patient_id,\n      appointment_time: data.appointment_time,\n      notes: data.notes || ''\n    });\n    return response;\n  } catch (error) {\n    var _error$response3;\n    // Handle specific error cases\n    if (error.status === 401) {\n      throw new Error('Authentication failed - please log in again');\n    }\n    if (error.status === 403) {\n      throw new Error('You do not have permission to book appointments');\n    }\n    if (error.status === 404) {\n      throw new Error('Doctor not found or not available');\n    }\n    if (error.status === 409) {\n      throw new Error('The selected time slot is no longer available. Please choose a different time.');\n    }\n    if (error.status === 422) {\n      var _error$response;\n      const validationMessage = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.message) || 'Invalid appointment data provided';\n      throw new Error(validationMessage);\n    }\n    if (error.status === 400) {\n      var _error$response2;\n      const badRequestMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.message) || 'Invalid request data';\n      throw new Error(badRequestMessage);\n    }\n\n    // Generic error handling\n    const message = ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.message) || error.message || 'Failed to book appointment';\n    throw new Error(message);\n  }\n};\n\n/**\n * Gets available time slots for a specific doctor on a given date\n * \n * @param doctorId - The ID of the doctor\n * @param date - The date to check availability (YYYY-MM-DD format)\n * @returns Promise<string[]> - Array of available time slots in ISO 8601 format\n * @throws Error - When the API request fails or returns an error\n */\nexport const getAvailableSlots = async (doctorId, date) => {\n  try {\n    if (!doctorId || !date) {\n      throw new Error('Doctor ID and date are required');\n    }\n    const response = await apiClient.get(`/appointments/availability?doctor_id=${doctorId}&date=${date}`);\n    return response;\n  } catch (error) {\n    var _error$response4;\n    if (error.status === 401) {\n      throw new Error('Authentication failed - please log in again');\n    }\n    if (error.status === 404) {\n      throw new Error('Doctor not found or no availability information');\n    }\n    const message = ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.message) || error.message || 'Failed to fetch available time slots';\n    throw new Error(message);\n  }\n};\n\n/**\n * Cancel an existing appointment\n * \n * @param id - The appointment ID to cancel\n * @param reason - Optional reason for cancellation\n * @returns Promise<ApiResponse> - Success response with cancellation confirmation\n * @throws {ApiError} When the request fails or appointment cannot be cancelled\n * \n * @openapi\n * /api/v1/appointments/{id}/cancel:\n *   delete:\n *     summary: Cancel an appointment\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: integer\n *         description: The appointment ID\n *     requestBody:\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               reason:\n *                 type: string\n *                 description: Optional reason for cancellation\n *     responses:\n *       200:\n *         description: Appointment cancelled successfully\n *       400:\n *         description: Invalid appointment ID or appointment cannot be cancelled\n *       401:\n *         description: Unauthorized - invalid or missing token\n *       404:\n *         description: Appointment not found\n *       500:\n *         description: Internal server error\n */\nexport const cancelAppointment = async (id, reason) => {\n  // Validate input\n  if (!id || id <= 0) {\n    throw new ApiError('Invalid appointment ID', 400);\n  }\n  try {\n    const requestBody = reason ? {\n      reason\n    } : {};\n    const response = await apiClient.delete(`/appointments/${id}/cancel`, {\n      data: requestBody\n    });\n    return {\n      message: response.message || 'Appointment cancelled successfully',\n      data: response.data\n    };\n  } catch (error) {\n    // Handle API errors\n    if (error.response) {\n      const {\n        status,\n        data\n      } = error.response;\n      throw new ApiError((data === null || data === void 0 ? void 0 : data.message) || (data === null || data === void 0 ? void 0 : data.error) || 'Failed to cancel appointment', status, data);\n    }\n\n    // Handle network or other errors\n    throw new ApiError(error.message || 'Network error occurred while cancelling appointment', 0);\n  }\n};","map":{"version":3,"names":["ApiError","apiClient","bookAppointment","data","doctor_id","patient_id","appointment_time","Error","appointmentDate","Date","isNaN","getTime","response","post","notes","error","_error$response3","status","_error$response","validationMessage","message","_error$response2","badRequestMessage","getAvailableSlots","doctorId","date","get","_error$response4","cancelAppointment","id","reason","requestBody","delete"],"sources":["/mnt/c/Users/HP/Smart-Doctor-Booking-Reminder-App/frontend/src/api/clients/appointmentApi.ts"],"sourcesContent":["import { BookingData, BookingResponse, ApiResponse, ApiError } from '../types/api';\nimport apiClient from './apiClient';\n\n/**\n * Books a new appointment with the specified doctor\n * \n * @param data - Booking data containing doctor_id, patient_id, appointment_time, and optional notes\n * @returns Promise<BookingResponse> - Booking confirmation with appointment details\n * @throws Error - When the API request fails or returns an error\n * \n * OpenAPI Specification:\n * POST /api/v1/appointments/book\n * \n * Request Body:\n * {\n *   \"doctor_id\": number,\n *   \"patient_id\": number,\n *   \"appointment_time\": string (ISO 8601 format),\n *   \"notes\": string (optional)\n * }\n * \n * Success Response (201):\n * {\n *   \"appointment_id\": number,\n *   \"doctor_id\": number,\n *   \"patient_id\": number,\n *   \"appointment_time\": string,\n *   \"status\": string,\n *   \"notes\": string,\n *   \"created_at\": string,\n *   \"message\": string\n * }\n * \n * Error Responses:\n * 400 - Bad Request (invalid data)\n * 401 - Unauthorized (authentication required)\n * 403 - Forbidden (insufficient permissions)\n * 404 - Not Found (doctor not found)\n * 409 - Conflict (time slot not available)\n * 422 - Unprocessable Entity (validation errors)\n */\nexport const bookAppointment = async (data: BookingData): Promise<BookingResponse> => {\n  try {\n    // Validate required fields\n    if (!data.doctor_id || !data.patient_id || !data.appointment_time) {\n      throw new Error('Doctor ID, Patient ID, and appointment time are required');\n    }\n\n    // Validate appointment time format (basic ISO 8601 check)\n    const appointmentDate = new Date(data.appointment_time);\n    if (isNaN(appointmentDate.getTime())) {\n      throw new Error('Invalid appointment time format. Please use ISO 8601 format.');\n    }\n\n    // Check if appointment time is in the future\n    if (appointmentDate <= new Date()) {\n      throw new Error('Appointment time must be in the future.');\n    }\n\n    const response = await apiClient.post<BookingResponse>(\n      '/appointments/book',\n      {\n        doctor_id: data.doctor_id,\n        patient_id: data.patient_id,\n        appointment_time: data.appointment_time,\n        notes: data.notes || ''\n      }\n    );\n\n    return response;\n  } catch (error: any) {\n    // Handle specific error cases\n    if (error.status === 401) {\n      throw new Error('Authentication failed - please log in again');\n    }\n    \n    if (error.status === 403) {\n      throw new Error('You do not have permission to book appointments');\n    }\n    \n    if (error.status === 404) {\n      throw new Error('Doctor not found or not available');\n    }\n    \n    if (error.status === 409) {\n      throw new Error('The selected time slot is no longer available. Please choose a different time.');\n    }\n    \n    if (error.status === 422) {\n      const validationMessage = error.response?.message || 'Invalid appointment data provided';\n      throw new Error(validationMessage);\n    }\n    \n    if (error.status === 400) {\n      const badRequestMessage = error.response?.message || 'Invalid request data';\n      throw new Error(badRequestMessage);\n    }\n    \n    // Generic error handling\n    const message = error.response?.message || error.message || 'Failed to book appointment';\n    throw new Error(message);\n  }\n};\n\n/**\n * Gets available time slots for a specific doctor on a given date\n * \n * @param doctorId - The ID of the doctor\n * @param date - The date to check availability (YYYY-MM-DD format)\n * @returns Promise<string[]> - Array of available time slots in ISO 8601 format\n * @throws Error - When the API request fails or returns an error\n */\nexport const getAvailableSlots = async (doctorId: number, date: string): Promise<string[]> => {\n  try {\n    if (!doctorId || !date) {\n      throw new Error('Doctor ID and date are required');\n    }\n\n    const response = await apiClient.get<string[]>(\n      `/appointments/availability?doctor_id=${doctorId}&date=${date}`\n    );\n\n    return response;\n  } catch (error: any) {\n    if (error.status === 401) {\n      throw new Error('Authentication failed - please log in again');\n    }\n    \n    if (error.status === 404) {\n      throw new Error('Doctor not found or no availability information');\n    }\n    \n    const message = error.response?.message || error.message || 'Failed to fetch available time slots';\n    throw new Error(message);\n  }\n};\n\n/**\n * Cancel an existing appointment\n * \n * @param id - The appointment ID to cancel\n * @param reason - Optional reason for cancellation\n * @returns Promise<ApiResponse> - Success response with cancellation confirmation\n * @throws {ApiError} When the request fails or appointment cannot be cancelled\n * \n * @openapi\n * /api/v1/appointments/{id}/cancel:\n *   delete:\n *     summary: Cancel an appointment\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: integer\n *         description: The appointment ID\n *     requestBody:\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               reason:\n *                 type: string\n *                 description: Optional reason for cancellation\n *     responses:\n *       200:\n *         description: Appointment cancelled successfully\n *       400:\n *         description: Invalid appointment ID or appointment cannot be cancelled\n *       401:\n *         description: Unauthorized - invalid or missing token\n *       404:\n *         description: Appointment not found\n *       500:\n *         description: Internal server error\n */\nexport const cancelAppointment = async (id: number, reason?: string): Promise<ApiResponse<any>> => {\n  // Validate input\n  if (!id || id <= 0) {\n    throw new ApiError('Invalid appointment ID', 400);\n  }\n\n  try {\n    const requestBody = reason ? { reason } : {};\n    \n    const response = await apiClient.delete<ApiResponse<any>>(\n      `/appointments/${id}/cancel`,\n      { data: requestBody }\n    );\n    \n    return {\n      message: response.message || 'Appointment cancelled successfully',\n      data: response.data\n    };\n  } catch (error: any) {\n    // Handle API errors\n    if (error.response) {\n      const { status, data } = error.response;\n      throw new ApiError(\n        data?.message || data?.error || 'Failed to cancel appointment',\n        status,\n        data\n      );\n    }\n    \n    // Handle network or other errors\n    throw new ApiError(\n      error.message || 'Network error occurred while cancelling appointment',\n      0\n    );\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}