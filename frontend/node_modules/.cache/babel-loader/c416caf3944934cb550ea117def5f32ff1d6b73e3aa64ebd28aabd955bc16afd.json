{"ast":null,"code":"// Authentication API client functions\nimport{storeToken,storeUser,getAuthHeader,getToken}from'../../utils/tokenStorage';import apiClient from'./apiClient';const AUTH_ENDPOINT=\"/api/v1/auth\";/**\n * Login function that calls POST /api/v1/auth/login\n * On success, stores the JWT token securely and returns user data\n * @param credentials - User login credentials\n * @returns Promise with user data\n * @throws Error with authentication failure details\n */export const login=async credentials=>{try{// Validate input\nif(!credentials.username||!credentials.password){throw new Error('Username and password are required');}// Make API request to backend\nconst response=await apiClient.post(\"\".concat(AUTH_ENDPOINT,\"/login\"),{username:credentials.username.trim(),password:credentials.password});const loginData=response;// Validate response structure\nif(!loginData.token||!loginData.username){throw new Error('Invalid response from server');}// Store token securely in sessionStorage\nstoreToken(loginData.token);// Store user information\nconst userData={user_id:loginData.user_id,username:loginData.username,role:loginData.role};storeUser(userData);return loginData;}catch(error){// Handle different types of errors\nif(error.status){var _error$response;// Server responded with error status\nconst errorMessage=((_error$response=error.response)===null||_error$response===void 0?void 0:_error$response.message)||error.message||'Authentication failed';throw new Error(errorMessage);}else{// Network error\nthrow new Error('Unable to connect to server. Please check your internet connection.');}}};/**\n * Validate the current JWT token with the backend\n * @returns Promise with validation result\n */export const validateToken=async()=>{try{const authHeader=getAuthHeader();if(!authHeader){throw new Error('No authentication token found');}const response=await apiClient.get(\"\".concat(AUTH_ENDPOINT,\"/validate\"));return response;}catch(error){if(error.status){var _error$response2;const message=((_error$response2=error.response)===null||_error$response2===void 0?void 0:_error$response2.message)||error.message||'Token validation failed';throw new Error(message);}else{throw new Error('Network error during token validation');}}};/**\n * Logout function that calls the backend logout endpoint\n * @returns Promise that resolves when logout is complete\n */export const logout=async()=>{try{const token=getToken();if(token){// Call backend logout endpoint\nawait apiClient.post(\"\".concat(AUTH_ENDPOINT,\"/logout\"),{});}}catch(error){// Log error but don't throw - logout should always succeed locally\nconsole.warn('Backend logout failed:',error);}};/**\n * Comprehensive logout function that handles both backend logout and local cleanup\n * This function calls POST /api/v1/auth/logout, clears stored JWT tokens, and can be used\n * independently or with AuthContext integration\n * \n * @returns Promise that resolves when logout process is complete\n * @throws Error only for critical failures that prevent local cleanup\n * \n * Usage:\n * ```typescript\n * // Standalone usage\n * await logoutUser();\n * \n * // With AuthContext (recommended)\n * const { logout } = useAuth();\n * await logout(); // This internally calls logoutUser\n * ```\n */export const logoutUser=async()=>{try{// Step 1: Call backend logout endpoint to invalidate token server-side\nawait logout();}catch(error){// Backend logout failed, but we should still clear local data\nconsole.warn('Backend logout failed, proceeding with local cleanup:',error);}// Step 2: Always clear local storage/session data regardless of backend response\n// Import clearAuthData here to avoid circular dependencies\nconst{clearAuthData}=await import('../../utils/tokenStorage');clearAuthData();// Note: If using with AuthContext, the context's logout function will also\n// dispatch the LOGOUT action to update the global state\n};// Note: The createAuthenticatedAxios function has been replaced by the new\n// secure API client utility (apiClient) which automatically handles\n// JWT token injection and authentication errors.","map":{"version":3,"names":["storeToken","storeUser","getAuthHeader","getToken","apiClient","AUTH_ENDPOINT","login","credentials","username","password","Error","response","post","concat","trim","loginData","token","userData","user_id","role","error","status","_error$response","errorMessage","message","validateToken","authHeader","get","_error$response2","logout","console","warn","logoutUser","clearAuthData"],"sources":["C:/Users/HP/Smart-Doctor-Booking-Reminder-App/frontend/src/api/clients/authApi.ts"],"sourcesContent":["// Authentication API client functions\n\nimport { LoginData, LoginResponse, TokenValidationResponse } from '../types/auth';\nimport { storeToken, storeUser, getAuthHeader, getToken } from '../../utils/tokenStorage';\nimport apiClient from './apiClient';\n\nconst AUTH_ENDPOINT = `/api/v1/auth`;\n\n/**\n * Login function that calls POST /api/v1/auth/login\n * On success, stores the JWT token securely and returns user data\n * @param credentials - User login credentials\n * @returns Promise with user data\n * @throws Error with authentication failure details\n */\nexport const login = async (credentials: LoginData): Promise<LoginResponse> => {\n  try {\n    // Validate input\n    if (!credentials.username || !credentials.password) {\n      throw new Error('Username and password are required');\n    }\n\n    // Make API request to backend\n    const response = await apiClient.post<LoginResponse>(\n      `${AUTH_ENDPOINT}/login`,\n      {\n        username: credentials.username.trim(),\n        password: credentials.password\n      }\n    );\n\n    const loginData = response;\n\n    // Validate response structure\n    if (!loginData.token || !loginData.username) {\n      throw new Error('Invalid response from server');\n    }\n\n    // Store token securely in sessionStorage\n    storeToken(loginData.token);\n\n    // Store user information\n    const userData = {\n      user_id: loginData.user_id,\n      username: loginData.username,\n      role: loginData.role\n    };\n    storeUser(userData);\n\n    return loginData;\n\n  } catch (error: any) {\n    // Handle different types of errors\n    if (error.status) {\n      // Server responded with error status\n      const errorMessage = error.response?.message || error.message || 'Authentication failed';\n      throw new Error(errorMessage);\n    } else {\n      // Network error\n      throw new Error('Unable to connect to server. Please check your internet connection.');\n    }\n  }\n};\n\n/**\n * Validate the current JWT token with the backend\n * @returns Promise with validation result\n */\nexport const validateToken = async (): Promise<TokenValidationResponse> => {\n  try {\n    const authHeader = getAuthHeader();\n    \n    if (!authHeader) {\n      throw new Error('No authentication token found');\n    }\n\n    const response = await apiClient.get<TokenValidationResponse>(\n      `${AUTH_ENDPOINT}/validate`\n    );\n\n    return response;\n\n  } catch (error: any) {\n    if (error.status) {\n      const message = error.response?.message || error.message || 'Token validation failed';\n      \n      throw new Error(message);\n    } else {\n      throw new Error('Network error during token validation');\n    }\n  }\n};\n\n/**\n * Logout function that calls the backend logout endpoint\n * @returns Promise that resolves when logout is complete\n */\nexport const logout = async (): Promise<void> => {\n  try {\n    const token = getToken();\n    \n    if (token) {\n      // Call backend logout endpoint\n      await apiClient.post(\n        `${AUTH_ENDPOINT}/logout`,\n        {}\n      );\n    }\n  } catch (error) {\n    // Log error but don't throw - logout should always succeed locally\n    console.warn('Backend logout failed:', error);\n  }\n};\n\n/**\n * Comprehensive logout function that handles both backend logout and local cleanup\n * This function calls POST /api/v1/auth/logout, clears stored JWT tokens, and can be used\n * independently or with AuthContext integration\n * \n * @returns Promise that resolves when logout process is complete\n * @throws Error only for critical failures that prevent local cleanup\n * \n * Usage:\n * ```typescript\n * // Standalone usage\n * await logoutUser();\n * \n * // With AuthContext (recommended)\n * const { logout } = useAuth();\n * await logout(); // This internally calls logoutUser\n * ```\n */\nexport const logoutUser = async (): Promise<void> => {\n  try {\n    // Step 1: Call backend logout endpoint to invalidate token server-side\n    await logout();\n  } catch (error) {\n    // Backend logout failed, but we should still clear local data\n    console.warn('Backend logout failed, proceeding with local cleanup:', error);\n  }\n  \n  // Step 2: Always clear local storage/session data regardless of backend response\n  // Import clearAuthData here to avoid circular dependencies\n  const { clearAuthData } = await import('../../utils/tokenStorage');\n  clearAuthData();\n  \n  // Note: If using with AuthContext, the context's logout function will also\n  // dispatch the LOGOUT action to update the global state\n};\n\n// Note: The createAuthenticatedAxios function has been replaced by the new\n// secure API client utility (apiClient) which automatically handles\n// JWT token injection and authentication errors."],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}